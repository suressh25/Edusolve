"""
Answer Booklet Compiler - Compiles Q&A into formatted Word/PDF documents
"""

import asyncio
from typing import List, Dict, Any
from pathlib import Path
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from datetime import datetime
from utils.logger import logger


class BookletCompiler:
    """Compile answers into professional Word/PDF documents"""

    def __init__(self):
        pass

    async def compile_to_word(
        self, answers: List[Dict[str, Any]], output_path: str, original_filename: str
    ) -> str:
        """Compile answers into Word document"""

        try:
            doc = Document()

            # Header section
            self._add_header(doc, original_filename)

            # Add each Q&A pair
            successful_answers = [a for a in answers if a.get("success", False)]

            for idx, answer_data in enumerate(successful_answers, 1):
                self._add_question_answer(doc, answer_data, idx)

                # Add page break after every 3 questions for better printing
                if idx % 3 == 0 and idx < len(successful_answers):
                    doc.add_page_break()

            # Footer with generation info
            self._add_footer(doc, len(successful_answers))

            # Save document
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)

            await asyncio.to_thread(doc.save, str(output_file))

            logger.info(f"Compiled answer booklet: {output_file}")
            return str(output_file)

        except Exception as e:
            logger.error(f"Error compiling Word document: {str(e)}")
            raise

    async def compile_to_pdf(
        self, answers: List[Dict[str, Any]], output_path: str, original_filename: str
    ) -> str:
        """Compile answers into PDF document"""

        try:
            # First create Word document
            word_path = output_path.replace(".pdf", ".docx")
            word_file = await self.compile_to_word(
                answers, word_path, original_filename
            )

            # Convert to PDF
            from docx2pdf import convert

            pdf_path = Path(output_path)
            pdf_path.parent.mkdir(parents=True, exist_ok=True)

            await asyncio.to_thread(convert, word_file, str(pdf_path))

            logger.info(f"Converted to PDF: {pdf_path}")
            return str(pdf_path)

        except Exception as e:
            logger.error(f"Error compiling PDF: {str(e)}")
            # Return Word file if PDF conversion fails
            logger.warning("PDF conversion failed, returning Word document")
            return word_file

    def _add_header(self, doc: Document, original_filename: str):
        """Add header to document"""

        # Title
        title = doc.add_heading("ANSWER BOOKLET", 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Subtitle
        subtitle = doc.add_paragraph(f"FOR: {original_filename}")
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle.runs[0].font.size = Pt(14)
        subtitle.runs[0].bold = True

        # Generated by line
        generated = doc.add_paragraph("Generated by EduSolve")
        generated.alignment = WD_ALIGN_PARAGRAPH.CENTER
        generated.runs[0].font.size = Pt(10)
        generated.runs[0].italic = True
        generated.runs[0].font.color.rgb = RGBColor(128, 128, 128)

        # Separator
        doc.add_paragraph("=" * 80)
        doc.add_paragraph()

    def _add_question_answer(
        self, doc: Document, answer_data: Dict[str, Any], index: int
    ):
        """Add single Q&A pair to document"""

        question_number = answer_data.get("question_number", index)
        question_text = answer_data.get("question_text", "N/A")
        marks = answer_data.get("marks", 0)
        answer_text = answer_data.get("answer", "N/A")

        # Question header
        q_header = doc.add_paragraph()
        q_header_run = q_header.add_run(f"Q{question_number}. {question_text} ")
        q_header_run.font.size = Pt(12)
        q_header_run.bold = True

        # Marks indicator
        marks_run = q_header.add_run(f"[{marks} marks]")
        marks_run.font.size = Pt(11)
        marks_run.font.color.rgb = RGBColor(0, 102, 204)
        marks_run.italic = True

        doc.add_paragraph()  # Spacing

        # Answer label
        answer_label = doc.add_paragraph()
        answer_label_run = answer_label.add_run("Answer:")
        answer_label_run.bold = True
        answer_label_run.font.size = Pt(11)
        answer_label_run.font.color.rgb = RGBColor(0, 128, 0)

        # Answer text
        answer_para = doc.add_paragraph(answer_text)
        answer_para.style = "Normal"
        answer_para.paragraph_format.left_indent = Inches(0.25)
        answer_para.paragraph_format.line_spacing = 1.15

        # Separator
        doc.add_paragraph("â”€" * 80)
        doc.add_paragraph()

    def _add_footer(self, doc: Document, total_answers: int):
        """Add footer information"""

        doc.add_paragraph()
        footer = doc.add_paragraph(
            f"\nTotal Questions Answered: {total_answers}\n"
            f'Generated on: {datetime.now().strftime("%B %d, %Y at %I:%M %p")}\n'
            f"Powered by EduSolve - GenAI Answer Generation System"
        )
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
        footer.runs[0].font.size = Pt(9)
        footer.runs[0].italic = True
        footer.runs[0].font.color.rgb = RGBColor(128, 128, 128)

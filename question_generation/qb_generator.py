"""
Question Bank Generator - Generates custom question banks from course materials
"""

import asyncio
from typing import List, Dict, Any
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from pathlib import Path
from utils.logger import logger


class QuestionBankGenerator:
    """Generate custom question banks from course materials"""

    def __init__(self, llm_router):
        self.llm_router = llm_router

    async def generate_questions(
        self,
        course_text: str,
        num_questions: int = 20,
        difficulty: str = "Medium",
        question_types: List[str] = None,
        marks_distribution: Dict[str, int] = None,
        topics: List[str] = None,
    ) -> List[Dict[str, Any]]:
        """Generate questions from course material"""

        if question_types is None:
            question_types = ["Short Answer", "Long Answer"]

        if marks_distribution is None:
            marks_distribution = {"2": 5, "5": 10, "10": 5}

        # Build marks distribution string
        marks_info = ", ".join(
            [f"{count}x {marks} marks" for marks, count in marks_distribution.items()]
        )

        # Build question types string
        types_info = ", ".join(question_types)

        # Build topics string
        topics_info = ", ".join(topics) if topics else "All topics in the material"

        generation_prompt = f"""You are an expert academic question paper creator. Generate {num_questions} high-quality exam questions based on the following course material.

Course Material:
{course_text[:10000]}

Requirements:
- Difficulty Level: {difficulty}
- Question Types: {types_info}
- Marks Distribution: {marks_info}
- Topics to Focus: {topics_info}
- Total Questions: {num_questions}

For each question, provide:
1. Question Number
2. Complete Question Text
3. Question Type
4. Marks Allocated
5. Topic/Concept Covered

Output in this exact JSON format:
[
  {{
    "question_number": "1",
    "question_text": "Complete question here",
    "question_type": "Short Answer",
    "marks": "2",
    "topic": "Topic name"
  }},
  ...
]

Guidelines:
- Ensure questions test understanding, not just memorization
- Cover diverse concepts from the material
- Match difficulty level appropriately
- Distribute marks according to specification
- Make questions clear and unambiguous"""

        try:
            response = await self.llm_router.generate(
                prompt=generation_prompt,
                max_tokens=6144,
                temperature=0.8,
                preferred_provider="groq",
            )

            # Parse JSON response
            import json
            import re

            json_match = re.search(r"\[.*\]", response["text"], re.DOTALL)
            if json_match:
                questions = json.loads(json_match.group())
                logger.info(
                    f"Generated {len(questions)} questions from course material"
                )
                return questions
            else:
                logger.error("Failed to parse generated questions")
                return []

        except Exception as e:
            logger.error(f"Question generation failed: {str(e)}")
            raise

    async def save_question_bank(
        self,
        questions: List[Dict[str, Any]],
        output_path: str,
        title: str = "Generated Question Bank",
    ) -> str:
        """Save generated questions to Word document"""

        try:
            doc = Document()

            # Title
            doc_title = doc.add_heading(title, 0)
            doc_title.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Stats
            stats = doc.add_paragraph(
                f"Total Questions: {len(questions)} | " f"Generated by EduSolve"
            )
            stats.alignment = WD_ALIGN_PARAGRAPH.CENTER
            stats.runs[0].italic = True

            doc.add_paragraph("=" * 80)
            doc.add_paragraph()

            # Add questions
            for q in questions:
                # Question header
                q_para = doc.add_paragraph()
                q_run = q_para.add_run(
                    f"Question Number: {q.get('question_number', 'N/A')}"
                )
                q_run.bold = True
                q_run.font.size = Pt(12)

                # Question text
                doc.add_paragraph(f"Question Text: {q.get('question_text', 'N/A')}")

                # Metadata
                metadata = doc.add_paragraph(
                    f"Type: {q.get('question_type', 'N/A')} | "
                    f"Marks: {q.get('marks', 'N/A')} | "
                    f"Topic: {q.get('topic', 'N/A')}"
                )
                metadata.runs[0].italic = True
                metadata.runs[0].font.size = Pt(10)

                # Separator
                doc.add_paragraph("â”€" * 80)

            # Save
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)

            await asyncio.to_thread(doc.save, str(output_file))

            logger.info(f"Saved generated question bank: {output_file}")
            return str(output_file)

        except Exception as e:
            logger.error(f"Error saving question bank: {str(e)}")
            raise
